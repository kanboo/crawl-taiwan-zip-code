# AI Rules

## CODING_PRACTICES

### SOLID 原則

- **S(SRP)**: 類別僅有單一變更理由
- **O(OCP)**: 擴展開放，修改封閉
- **L(LSP)**: 子類須能完整替換父類
- **I(ISP)**: 客戶端不依賴不需要的介面
- **D(DIP)**: 依賴抽象，非實現

### 實務準則

- **DRY**: 避免重複，但遵循「三次法則」—重複三次後才抽象
- **YAGNI**: 只實現當前需求，避免過度設計
- **失敗快速**: 及早暴露問題，不掩蓋錯誤
- **純函數優先**: 相同輸入產生相同輸出，無副作用
- **CQS**: 方法要麼執行動作，要麼返回結果，不可兩者兼具
- **最小驚訝**: 行為應符合命名暗示的預期

### 錯誤處理精要

- **透明報告**: 明確報告問題來源及性質，如「資料庫連接失敗」vs「查詢語法錯誤」
- **適度容錯**: 僅業務要求時實現降級，否則拒絕錯誤輸入
- **完整日誌**: 記錄錯誤與上下文，但勿自動「修復」隱藏問題

### 設計結構準則

- **風格統一**: 遵循專案命名慣例與格式標準
- **低耦合高內聚**: 相關功能集中，使用介面設計與依賴注入
- **表達性命名**: 名稱反映意圖，註釋說明「為何」非「是何」
- **簡潔邏輯**: 避免深層巢狀結構，拆分複雜條件

### 平衡策略

- **重複 vs 抽象**: 三次重複後再抽象，模式確定再重構
- **失敗 vs 防禦**: 業務核心快速失敗，UI 層適度防禦
- **靈活應用**: 基於專案特性、團隊規模、階段選擇適合原則
- **漸進複雜**: 先用簡單方案，需求證實後才增加複雜度
- **例外管理**: 違反原則時記錄理由並達成共識

### 重構考量

- **UI 相容性**: 確認事件處理、數據綁定與視覺反饋
- **依賴分析**: 辨識顯式依賴(引用)與隱式依賴(假設)
- **介面穩定**: 採「擴展不修改」策略，使用棄用標記
- **迭代改進**: 提出 → 評估 → 修改 → 重新評估，利用多方反饋
- **禁忌行為**: 避免架構衝突、炫技複雜化、過度寬容錯誤

### 反思檢查清單

1. 符合整體架構？
2. 複雜度恰當？
3. 影響範圍明確？
4. 存在更簡方案？
5. 能適應需求變化？
6. 錯誤處理完善？
7. 容錯水平合理？

### 實施優先序

1. **修正錯誤** → 2. **優化效能** → 3. **提升可讀性** → 4. **消除冗餘**
